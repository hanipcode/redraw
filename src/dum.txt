function useAnimator(
  statefulData: StatefulData,
  param: RecursivePartial<UseAnimatorParam> = {}
) {
  const defaultParam: RecursivePartial<UseAnimatorParam> = {
    speed: 1,
    maxSpeed: Number.POSITIVE_INFINITY,
  };
  const combinedParam = {
    ...defaultParam,
    ...param,
  };
  const { boundingBox, maxSpeed } = combinedParam as UseAnimatorParam;
  let { speed } = combinedParam as UseAnimatorParam;
  let dV: Vector2 = {
    x: 0,
    y: 0,
  };
  let dTime = 0;

  let animationFrame;
  function loop() {
    let component: Component<InitialState> = statefulData.getComponent();
    if (!component) {
      stopLoop();
      return;
    }

    const newPosX = component.state.position.x + dV.x;
    const newPosY = component.state.position.y + dV.y;

    // if bounding box is defined, can't move outside bounding box
    // can't move horizontally outside bounding box X if defined
    if (boundingBox) {
      if (boundingBox.x) {
        if (newPosX <= boundingBox.x[0] || newPosX >= boundingBox.x[1]) {
          dV.x = 0;
          component.setState({ physics: { velocity: dV } });
          stopLoop();
          return;
        }
      }
      // can't move vertically outside bounding box y if defined
      if (boundingBox.y) {
        if (newPosY <= boundingBox.y[0] || newPosY >= boundingBox.y[1]) {
          dV.y = 0;
          component.setState({ physics: { velocity: dV } });
          stopLoop();
          return;
        }
      }
    }

    if (dV.x > 0 || dV.x < 0) {
      dV.x *= 1 - speed * 0.001;
      component.setState({
        position: { x: newPosX },
        physics: { velocity: dV },
      });
    }
    if (dV.y > 0 || dV.y < 0) {
      dV.y *= 1 - speed * 0.001;
      component.setState({
        position: { y: newPosY },
        physics: { velocity: dV },
      });
    }

    animationFrame = requestAnimationFrame(loop);
  }

  const startLoop = () => {
    loop();
  };
  const stopLoop = () => {
    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
    }
  };

  const animateLeft = (speedParam = speed) => {
    stopLoop();
    if (dV.x > 0) {
      dV.x = 0;
    }
    dV.x -= speed * TIME.deltaTime;
    if (dV.x < maxSpeed * -1) {
      dV.x = maxSpeed * -1;
    }
    startLoop();
  };

  const animateUp = () => {
    stopLoop();
    if (dV.x < 0) {
      dV.x = 0;
    }
    dV.y -= speed * TIME.deltaTime;
    if (dV.y < maxSpeed * -1) {
      dV.y = maxSpeed * -1;
    }
    startLoop();
  };

  const animateRight = () => {
    stopLoop();
    if (dV.x < 0) {
      dV.x = 0;
    }
    dV.x += speed * TIME.deltaTime;
    if (dV.x > maxSpeed) {
      dV.x = maxSpeed;
    }
    startLoop();
  };

  const animateDown = () => {
    stopLoop();
    dV.y += speed * TIME.deltaTime;
    if (dV.y > maxSpeed) {
      dV.y = maxSpeed;
    }
    startLoop();
  };

  const deccelerate = (factor: number | Vector2 = 0.04) => {
    dV = multiplyVector(dV, factor);
  };

  const updateVelocity = (velocity: Vector2) => {
    dV = velocity;
  };

  const getCurrentVelocity = (): Vector2 => dV;

  const updateSpeed = (newSpeed: number) => {
    speed = newSpeed;
  };

  const getCurrentSpeed = (): number => speed;

  return {
    updateSpeed,
    getCurrentSpeed,
    updateVelocity,
    getCurrentVelocity,
    animateLeft,
    animateRight,
    deccelerate,
    animateUp,
    animateDown,
  };
}

function useAnimator(
  statefulData: StatefulData,
  param: RecursivePartial<UseAnimatorParam> = {}
) {
  const defaultParam: RecursivePartial<UseAnimatorParam> = {
    speed: 1,
    maxSpeed: Number.POSITIVE_INFINITY,
  };
  const combinedParam = {
    ...defaultParam,
    ...param,
  };
  const { boundingBox, maxSpeed } = combinedParam as UseAnimatorParam;
  let { speed } = combinedParam as UseAnimatorParam;
  let dV: Vector2 = {
    x: 0,
    y: 0,
  };
  let dTime = 0;

  let animationFrame;
  function loop() {
    let component: Component<InitialState> = statefulData.getComponent();
    if (!component) {
      stopLoop();
      return;
    }

    const newPosX = component.state.position.x + dV.x;
    const newPosY = component.state.position.y + dV.y;

    // if bounding box is defined, can't move outside bounding box
    // can't move horizontally outside bounding box X if defined
    if (boundingBox) {
      if (boundingBox.x) {
        if (newPosX <= boundingBox.x[0] || newPosX >= boundingBox.x[1]) {
          dV.x = 0;
          component.setState({ physics: { velocity: dV } });
          stopLoop();
          return;
        }
      }
      // can't move vertically outside bounding box y if defined
      if (boundingBox.y) {
        if (newPosY <= boundingBox.y[0] || newPosY >= boundingBox.y[1]) {
          dV.y = 0;
          component.setState({ physics: { velocity: dV } });
          stopLoop();
          return;
        }
      }
    }

    if (dV.x > 0 || dV.x < 0) {
      dV.x *= 1 - speed * 0.001;
      component.setState({
        position: { x: newPosX },
        physics: { velocity: dV },
      });
    }
    if (dV.y > 0 || dV.y < 0) {
      dV.y *= 1 - speed * 0.001;
      component.setState({
        position: { y: newPosY },
        physics: { velocity: dV },
      });
    }

    animationFrame = requestAnimationFrame(loop);
  }

  const startLoop = () => {
    loop();
  };
  const stopLoop = () => {
    if (animationFrame) {
      cancelAnimationFrame(animationFrame);
    }
  };

  const animateLeft = (speedParam = speed) => {
    stopLoop();
    if (dV.x > 0) {
      dV.x = 0;
    }
    dV.x -= speed * TIME.deltaTime;
    if (dV.x < maxSpeed * -1) {
      dV.x = maxSpeed * -1;
    }
    startLoop();
  };

  const animateUp = () => {
    stopLoop();
    if (dV.x < 0) {
      dV.x = 0;
    }
    dV.y -= speed * TIME.deltaTime;
    if (dV.y < maxSpeed * -1) {
      dV.y = maxSpeed * -1;
    }
    startLoop();
  };

  const animateRight = () => {
    stopLoop();
    if (dV.x < 0) {
      dV.x = 0;
    }
    dV.x += speed * TIME.deltaTime;
    if (dV.x > maxSpeed) {
      dV.x = maxSpeed;
    }
    startLoop();
  };

  const animateDown = () => {
    stopLoop();
    dV.y += speed * TIME.deltaTime;
    if (dV.y > maxSpeed) {
      dV.y = maxSpeed;
    }
    startLoop();
  };

  const deccelerate = (factor: number | Vector2 = 0.04) => {
    dV = multiplyVector(dV, factor);
  };

  const updateVelocity = (velocity: Vector2) => {
    dV = velocity;
  };

  const getCurrentVelocity = (): Vector2 => dV;

  const updateSpeed = (newSpeed: number) => {
    speed = newSpeed;
  };

  const getCurrentSpeed = (): number => speed;

  return {
    updateSpeed,
    getCurrentSpeed,
    updateVelocity,
    getCurrentVelocity,
    animateLeft,
    animateRight,
    deccelerate,
    animateUp,
    animateDown,
  };
}
import "./jsxTyping";

const PrebuiltComponents = {
  Text: "Text",
  Canvas: "Canvas",
  Background: "Background",
} as const;

interface Component {
  componentId: number;
  type: Component | Component[] | string | Function;
  props: any;
}

type ChildrenType = Component | Component[] | string | Function;
interface CreateElementParam {
  props: any;
  children?: ChildrenType;
}

let lastComponentId = 0;
let lastRenderedComponentId = 0;
let Components = {};
const ComponentStates: Record<string, any[]> = {};
type EffectDependencyType = any[];
type EffectId = number;
let ComponentEffects: Record<
  string,
  Array<[EffectFn, EffectDependencyType, EffectId]>
> = {};
const EffectDependencies: Record<EffectId, any[]> = {};
const CleanupEffectFunctions: Record<EffectId, CleanupEffectFn> = {};

function prepareProps(props) {
  if (!props) {
    // @ts-ignore
    props = {};
  }
  if (!props.props) {
    props.props = {};
  }

  if (!props.children) {
    props.children = [];
  }

  if (!props.children) {
    props.children = [];
  }
  return props;
}
function createElement(
  type: string | Function | Component,
  props?: CreateElementParam,
  ...childArg: Component[]
): Component {
  if ((type as Component).type) {
    return type as Component;
  }
  const preparedProps = prepareProps(props);
  if (Array.isArray(preparedProps.children)) {
    preparedProps.children = preparedProps.children.map((child) =>
      createElement(child)
    );
  }
  if (Array.isArray(type)) {
    const typeChild = type.map((child) => createElement(child));
    preparedProps.children = [...preparedProps.children, ...typeChild];
  }
  if (typeof preparedProps.children === "string") {
    preparedProps.children = preparedProps.children;
  }

  if (Array.isArray(childArg) && childArg.length > 0) {
    const childComp = childArg.map((child) => {
      return createElement(child);
    });
    preparedProps.children = [...preparedProps.children, ...childComp];
  }
  if (typeof type === "function") {
    return createElement(type(preparedProps));
  }
  const component = {
    componentId: lastComponentId,
    type,
    props: {
      ...preparedProps,
      ...preparedProps.props,
    },
  };
  Components[lastComponentId] = component;
  lastComponentId += 1;
  return component;
}

function setComponentStates(componentId: number, state: any, stateId: number) {
  if (!ComponentStates[componentId]) {
    ComponentStates[componentId] = [];
  }
  ComponentStates[componentId][stateId] = state;
}

type CleanupEffectFn = () => void | undefined;
type EffectFn = () => CleanupEffectFn | void;

function setEffect(
  componentId: number,
  effectData: [EffectFn, EffectDependencyType, EffectId]
) {
  if (!ComponentEffects[componentId]) {
    ComponentEffects[componentId] = [];
  }
  ComponentEffects[componentId].push(effectData);
}

function setEffectDependencies(effectId: EffectId, dependencies: any[]) {
  EffectDependencies[effectId] = dependencies;
}

function getEffect(
  componentId
): Array<[EffectFn, EffectDependencyType, EffectId]> {
  return ComponentEffects[componentId] || [];
}

function useEffect(effect: EffectFn, dependencies: any[]) {
  if (!Array.isArray(dependencies)) {
    throw new Error(
      `You are using useEffect in ${Components[lastComponentId].type} without dependencies of type Array!`
    );
  }
  const currentEffects = getEffect(lastComponentId);
  setEffect(lastComponentId, [effect, dependencies, currentEffects.length]);
}

function resetComponent() {
  Components = {};
}

function runEffectCleanups() {
  ComponentEffects = {};
}

function processEffect(componentId) {
  const effects = getEffect(componentId);
  if (Array.isArray(effects) && effects.length > 0) {
    effects.forEach(([effectFn, dependency, effectId]) => {
      const effectDependencies = EffectDependencies[effectId];
      // if !effectDependencies mean initial
      if (!effectDependencies) {
        const cleanupEffectFn = effectFn();
        setEffectDependencies(effectId, dependency);
        if (typeof cleanupEffectFn === "function") {
          CleanupEffectFunctions[effectId] = cleanupEffectFn;
        }
        return;
      }
      if (dependency.length !== effectDependencies.length) {
        throw new Error(
          `Dependencies effect cannot be dynamic. check ${Components[componentId].type}`
        );
      }
      let isSameDependency = true;
      for (let i = 0; i < dependency.length; i++) {
        if (dependency[i] === effectDependencies[i]) {
          isSameDependency = false;
        }
      }
      if (!isSameDependency) {
        // run previous cleanup
        if (CleanupEffectFunctions[effectId]) {
          CleanupEffectFunctions[effectId]();
        }
        effectFn();
      }
    });
  }
}

function useState(initialState: any) {
  const stateId = ComponentStates[lastComponentId]
    ? ComponentStates[lastComponentId].length - 1
    : 0;
  const currentState = ComponentStates[lastComponentId]
    ? ComponentStates[lastComponentId][stateId]
    : initialState;
  // if state still empty for this component
  if (!ComponentStates[lastComponentId]) {
    ComponentStates[lastComponentId] = [];
  }
  // initState
  if (ComponentStates[lastComponentId][stateId] === undefined) {
    setComponentStates(lastComponentId, initialState, stateId);
  }
  const setState = (stateUpdater) => {
    if (typeof stateUpdater === "function") {
      const lastState = ComponentStates[lastComponentId]
        ? ComponentStates[lastComponentId][stateId]
        : initialState;
      setComponentStates(lastComponentId, stateUpdater(lastState), stateId);
      return;
    }
    setComponentStates(lastComponentId, stateUpdater, stateId);
  };
  return [currentState, setState];
}

const InternalCanvasId = "_internalCanvasId";
let canvas: HTMLCanvasElement;
let ctx: CanvasRenderingContext2D;

function createGameCanvas(component: Component): HTMLCanvasElement {
  const canvas = document.createElement("canvas");
  canvas.id = InternalCanvasId;
  canvas.width = component.props.width || 450;
  canvas.height = component.props.height || 650;
  return canvas;
}

function drawTextNode(text: string, textComponent: Component) {
  const offsetY = textComponent.props.offset
    ? textComponent.props.offset + 30
    : 30;
  ctx.fillText(text, 10, offsetY);
}

type DrawerFn = (component: Component) => void;
function CanvasComponentDrawer() {
  const drawCanvas: DrawerFn = (component) => {
    const currentCanvas = getCanvas();
    if (!currentCanvas) {
      canvas = createGameCanvas(component);
      ctx = canvas.getContext("2d")!;
      document.getElementById("root")?.appendChild(canvas);
      return;
    }
  };
  const drawBackground: DrawerFn = (component) => {
    const { props = {} } = component;
    ctx.fillStyle = props.background || "black";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    return;
  };
  const drawText: DrawerFn = (component) => {
    const { props = {} } = component;
    ctx.font = props.font || "16px Arial";
    ctx.fillStyle = props.fillStyle || "#000";
    if (Array.isArray(component.props.children)) {
      let textStr = "";

      component.props.children.forEach((child) => {
        if (typeof child.type === "string" || typeof child.type === "number") {
          textStr += child.type;
        } else {
          throw new Error("text component can only render string or number");
        }
      });
      drawTextNode(textStr, component);
    }
  };
  const Drawer: Record<keyof typeof PrebuiltComponents, DrawerFn> = {
    [PrebuiltComponents.Canvas]: drawCanvas,
    [PrebuiltComponents.Background]: drawBackground,
    [PrebuiltComponents.Text]: drawText,
    // no op
  };

  return Drawer;
}

const CanvasDrawer = CanvasComponentDrawer();
const getDrawFn = (componentType: string) => {
  return CanvasDrawer[componentType] || undefined;
};

function drawComponent(component: Component) {
  // const componentEff = getEffect(component.componentId);
  processEffect(component.componentId);
  const drawFn = getDrawFn(component.type as string);
  if (drawFn) {
    drawFn(component);
  }
}

function handleChildren(children: Component) {
  if ((children as Component).type) {
    drawComponent(children as Component);
  }
  // render if single child
  if ((children as Component).type) {
    renderLoop(children as Component);
  }
  if (Array.isArray(children)) {
    children.forEach(renderLoop);
  }
}
function renderLoop(component: Component) {
  const { props = {} } = component;
  lastRenderedComponentId += 1;
  drawComponent(component);
  // recurse child
  if (Array.isArray(props.children) && props.children.length > 0) {
    handleChildren(props.children);
  }
}

function getCanvas(): HTMLCanvasElement {
  const canvas: HTMLCanvasElement = document.getElementById(
    InternalCanvasId
  ) as HTMLCanvasElement;
  return canvas;
}

function clearCanvas() {
  const canvas = getCanvas();
  if (!canvas) return;
  const context = canvas.getContext("2d")!;
  context.clearRect(0, 0, canvas.width, canvas.height);
}

function render(component: Component) {
  lastComponentId = 0;
  lastRenderedComponentId = 0;
  renderLoop(component);
}

function Background(props) {
  return createElement(PrebuiltComponents.Background, {
    props,
  });
}

function GameCanvas(props) {
  return createElement(PrebuiltComponents.Canvas, { props });
}

function Text(props) {
  return createElement(PrebuiltComponents.Canvas, { props });
}

function startGame(component: () => Component) {
  function gameLoop() {
    clearCanvas();
    resetComponent();
    runEffectCleanups();
    render(component());
    requestAnimationFrame(gameLoop);
  }
  gameLoop();
}

export { startGame, GameCanvas, Background, useEffect, useState, Text };
let Redraw;
Redraw = (window as any).Redraw = {
  createElement,
};
export default Redraw;
